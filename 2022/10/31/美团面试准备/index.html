<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis常见数据类型和应用场景1.String（SDS） SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。 **SDS 获取字符串长度">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/10/31/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis常见数据类型和应用场景1.String（SDS） SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。 **SDS 获取字符串长度">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2022-10-31T03:41:15.101Z">
<meta property="article:modified_time" content="2022-10-31T03:39:00.130Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/10/31/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hexo',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-31 11:39:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-31T03:41:15.101Z" title="Created 2022-10-31 11:41:15">2022-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-10-31T03:39:00.130Z" title="Updated 2022-10-31 11:39:00">2022-10-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis常见数据类型和应用场景"><a href="#Redis常见数据类型和应用场景" class="headerlink" title="Redis常见数据类型和应用场景"></a>Redis常见数据类型和应用场景</h1><h2 id="1-String（SDS）"><a href="#1-String（SDS）" class="headerlink" title="1.String（SDS）"></a>1.String（SDS）</h2><ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/image-20221018232309602.png" alt="image-20221018232309602" style="zoom: 80%;" />

<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> name lin</span><br><span class="line">OK</span><br><span class="line"># 根据 key 获得对应的 <span class="keyword">value</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">GET</span> name</span><br><span class="line">&quot;lin&quot;</span><br><span class="line"># 判断某个 key 是否存在</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">EXISTS</span> name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 返回 key 所储存的字符串值的长度</span><br><span class="line"><span class="operator">&gt;</span> STRLEN name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"># 删除某个 key 对应的值</span><br><span class="line"><span class="operator">&gt;</span> DEL name</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 批量设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> MSET key1 value1 key2 value2 </span><br><span class="line">OK</span><br><span class="line"># 批量获取多个 key 对应的 <span class="keyword">value</span></span><br><span class="line"><span class="operator">&gt;</span> MGET key1 key2 </span><br><span class="line"><span class="number">1</span>) &quot;value1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="场景使用"><a href="#场景使用" class="headerlink" title="场景使用"></a>场景使用</h3><h4 id="1-计数器（计算访问次数、转发、库存数量、文章的阅读量等等）"><a href="#1-计数器（计算访问次数、转发、库存数量、文章的阅读量等等）" class="headerlink" title="1.计数器（计算访问次数、转发、库存数量、文章的阅读量等等）"></a><strong>1.计数器（计算访问次数、转发、库存数量、文章的阅读量等等）</strong></h4><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> number <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line"># 将 key 中储存的数字值增一</span><br><span class="line"><span class="operator">&gt;</span> INCR number</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 将key中存储的数字值加 <span class="number">10</span></span><br><span class="line"><span class="operator">&gt;</span> INCRBY number <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">11</span></span><br><span class="line"># 将 key 中储存的数字值减一</span><br><span class="line"><span class="operator">&gt;</span> DECR number</span><br><span class="line">(<span class="type">integer</span>) <span class="number">10</span></span><br><span class="line"># 将key中存储的数字值减 <span class="number">10</span></span><br><span class="line"><span class="operator">&gt;</span> DECRBY number <span class="number">10</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">#过期（默认为永不过期）：</span><br><span class="line"># 设置 key 在 <span class="number">60</span> 秒后过期（该方法是针对已经存在的key设置过期时间）</span><br><span class="line"><span class="operator">&gt;</span> EXPIRE name  <span class="number">60</span> </span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># 查看数据还有多久过期</span><br><span class="line"><span class="operator">&gt;</span> TTL name </span><br><span class="line">(<span class="type">integer</span>) <span class="number">51</span></span><br><span class="line"></span><br><span class="line">#设置 key<span class="operator">-</span><span class="keyword">value</span> 类型的值，并设置该key的过期时间为 <span class="number">60</span> 秒</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> key  <span class="keyword">value</span> EX <span class="number">60</span></span><br><span class="line">OK</span><br><span class="line"><span class="operator">&gt;</span> SETEX key  <span class="number">60</span> <span class="keyword">value</span></span><br><span class="line">OK</span><br><span class="line"># 不存在就插入（<span class="keyword">not</span> <span class="keyword">exists</span>）</span><br><span class="line"><span class="operator">&gt;</span>SETNX key <span class="keyword">value</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 初始化文章的阅读量</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">SET</span> aritcle:readcount:<span class="number">1001</span> <span class="number">0</span></span><br><span class="line">OK</span><br><span class="line">#阅读量<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> INCR aritcle:readcount:<span class="number">1001</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">#阅读量<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> INCR aritcle:readcount:<span class="number">1001</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line">#阅读量<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> INCR aritcle:readcount:<span class="number">1001</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">3</span></span><br><span class="line"># 获取对应文章的阅读量</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">GET</span> aritcle:readcount:<span class="number">1001</span></span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-缓存对象（用户信息等）"><a href="#2-缓存对象（用户信息等）" class="headerlink" title="2.缓存对象（用户信息等）"></a><strong>2.缓存对象（用户信息等）</strong></h4><p>使用 String 来缓存对象有两种方式：</p>
<ul>
<li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li>
<li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li>
</ul>
<h4 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3.分布式锁"></a><strong>3.分布式锁</strong></h4><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> lock_key unique_value NX PX <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，**解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端(可重入锁推荐使用哈希)**，是的话，才将 lock_key 键删除。</p>
<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p>
<h4 id="4-共享Session信息"><a href="#4-共享Session信息" class="headerlink" title="4.共享Session信息"></a><strong>4.共享Session信息</strong></h4><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018234606131.png" alt="image-20221018234606131" style="zoom:50%;" />

<h2 id="2-List（压缩列表-双向链表）"><a href="#2-List（压缩列表-双向链表）" class="headerlink" title="2.List（压缩列表+双向链表）"></a>2.List（压缩列表+双向链表）</h2><ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 将一个或多个值<span class="keyword">value</span>插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...] </span><br><span class="line"># 将一个或多个值<span class="keyword">value</span>插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key <span class="keyword">value</span> [<span class="keyword">value</span> ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量<span class="keyword">start</span>和stop指定，从<span class="number">0</span>开始</span><br><span class="line">LRANGE key <span class="keyword">start</span> stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout<span class="operator">=</span><span class="number">0</span>则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout<span class="operator">=</span><span class="number">0</span>则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h4><ul>
<li><p>消息保序：使用 LPUSH + RPOP；</p>
</li>
<li><p>阻塞读取：使用 BRPOP；</p>
</li>
<li><p>重复消息处理：生产者自行实现全局唯一 ID；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#把一条全局 ID 为 <span class="number">111000102</span>、库存量为 <span class="number">99</span> 的消息插入了消息队列,消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</span><br><span class="line"><span class="operator">&gt;</span> LPUSH mq &quot;111000102:stock:99&quot;</span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>消息的可靠性：使用 BRPOPLPUSH</p>
<p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
</li>
</ul>
<p>缺陷：List 不支持多个消费者消费同一条消息，不支持消费者组的实现</p>
<h2 id="3-Hash（压缩列表-哈希表）"><a href="#3-Hash（压缩列表-哈希表）" class="headerlink" title="3.Hash（压缩列表+哈希表）"></a>3.Hash（压缩列表+哈希表）</h2><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 存储一个哈希表key的键值</span><br><span class="line">HSET key field <span class="keyword">value</span>   </span><br><span class="line"># 获取哈希表key对应的field键值</span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line"># 在一个哈希表key中存储多个键值对</span><br><span class="line">HMSET key field <span class="keyword">value</span> [field value...] </span><br><span class="line"># 批量获取哈希表key中多个field键值</span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"># 删除哈希表key中的field键值</span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"></span><br><span class="line"># 返回哈希表key中field的数量</span><br><span class="line">HLEN key       </span><br><span class="line"># 返回哈希表key中所有的键值</span><br><span class="line">HGETALL key </span><br><span class="line"></span><br><span class="line"># 为哈希表key中field键的值加上增量n</span><br><span class="line">HINCRBY key field n </span><br></pre></td></tr></table></figure>

<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="缓存对象-如购物车"><a href="#缓存对象-如购物车" class="headerlink" title="缓存对象(如购物车)"></a><strong>缓存对象(如购物车)</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 存储一个哈希表uid:<span class="number">1</span>的键值</span><br><span class="line"><span class="operator">&gt;</span> HMSET uid:<span class="number">1</span> name Tom age <span class="number">15</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"># 存储一个哈希表uid:<span class="number">2</span>的键值</span><br><span class="line"><span class="operator">&gt;</span> HMSET uid:<span class="number">2</span> name Jerry age <span class="number">13</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"># 获取哈希表用户id为<span class="number">1</span>中所有的键值</span><br><span class="line"><span class="operator">&gt;</span> HGETALL uid:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;name&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Tom&quot;</span><br><span class="line"><span class="number">3</span>) &quot;age&quot;</span><br><span class="line"><span class="number">4</span>) &quot;15&quot;</span><br></pre></td></tr></table></figure>

<p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221019104509103.png" alt="image-20221019104509103" style="zoom:50%;" />

<p>涉及的命令如下：</p>
<ul>
<li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li>
<li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li>
</ul>
<p>当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p>
<h2 id="4-Set（整数集合-哈希表）"><a href="#4-Set（整数集合-哈希表）" class="headerlink" title="4.Set（整数集合+哈希表）"></a>4.Set（整数集合+哈希表）</h2><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SADD key <span class="keyword">member</span> [<span class="keyword">member</span> ...]</span><br><span class="line"># 从集合key中删除元素</span><br><span class="line">SREM key <span class="keyword">member</span> [<span class="keyword">member</span> ...] </span><br><span class="line"># 获取集合key中所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line"># 获取集合key中的元素个数</span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"># 判断<span class="keyword">member</span>元素是否存在于集合key中</span><br><span class="line">SISMEMBER key <span class="keyword">member</span></span><br><span class="line"></span><br><span class="line"># 从集合key中随机选出count个元素，元素不从key中删除</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"># 从集合key中随机选出count个元素，元素从key中删除</span><br><span class="line">SPOP key [count]</span><br><span class="line"></span><br><span class="line">#<span class="keyword">Set</span>运算操作</span><br><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>



<h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p>
<p>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h4 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a><strong>点赞</strong></h4><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># uid:<span class="number">1</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># uid:<span class="number">2</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line"># uid:<span class="number">3</span> 用户对文章 article:<span class="number">1</span> 点赞</span><br><span class="line"><span class="operator">&gt;</span> SADD article:<span class="number">1</span> uid:<span class="number">3</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">#uid:<span class="number">1</span> 取消了对 article:<span class="number">1</span> 文章点赞。</span><br><span class="line"><span class="operator">&gt;</span> SREM article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">#获取 article:<span class="number">1</span> 文章所有点赞用户 :</span><br><span class="line"><span class="operator">&gt;</span> SMEMBERS article:<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;uid:3&quot;</span><br><span class="line"><span class="number">2</span>) &quot;uid:2&quot;</span><br><span class="line">#获取 article:<span class="number">1</span> 文章的点赞用户数量：</span><br><span class="line"><span class="operator">&gt;</span> SCARD article:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line">#判断用户 uid:<span class="number">1</span> 是否对文章 article:<span class="number">1</span> 点赞了：</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER article:<span class="number">1</span> uid:<span class="number">1</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span>  # 返回<span class="number">0</span>说明没点赞，返回<span class="number">1</span>则说明点赞了</span><br></pre></td></tr></table></figure>

<h4 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a><strong>共同关注</strong></h4><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># uid:<span class="number">1</span> 用户关注公众号 id 为 <span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span></span><br><span class="line"><span class="operator">&gt;</span> SADD uid:<span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"># uid:<span class="number">2</span>  用户关注公众号 id 为 <span class="number">7</span>、<span class="number">8</span>、<span class="number">9</span>、<span class="number">10</span>、<span class="number">11</span></span><br><span class="line"><span class="operator">&gt;</span> SADD uid:<span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line">#uid:<span class="number">1</span> 和 uid:<span class="number">2</span> 共同关注的公众号：</span><br><span class="line"># 获取共同关注</span><br><span class="line"><span class="operator">&gt;</span> SINTER uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;7&quot;</span><br><span class="line"><span class="number">2</span>) &quot;8&quot;</span><br><span class="line"><span class="number">3</span>) &quot;9&quot;</span><br><span class="line">#给 uid:<span class="number">2</span> 推荐 uid:<span class="number">1</span> 关注的公众号：</span><br><span class="line"><span class="operator">&gt;</span> SDIFF uid:<span class="number">1</span> uid:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;5&quot;</span><br><span class="line"><span class="number">2</span>) &quot;6&quot;</span><br><span class="line">#验证某个公众号是否同时被 uid:<span class="number">1</span> 或 uid:<span class="number">2</span> 关注:</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER uid:<span class="number">1</span> <span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span> # 返回<span class="number">0</span>，说明关注了</span><br><span class="line"><span class="operator">&gt;</span> SISMEMBER uid:<span class="number">2</span> <span class="number">5</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">0</span> # 返回<span class="number">0</span>，说明没关注</span><br></pre></td></tr></table></figure>

<h4 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a><strong>抽奖活动</strong></h4><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span>SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br><span class="line">(<span class="type">integer</span>) <span class="number">5</span></span><br><span class="line"></span><br><span class="line">#如果允许重复中奖，可以使用 SRANDMEMBER 命令。</span><br><span class="line"># 抽取 <span class="number">1</span> 个一等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;Tom&quot;</span><br><span class="line"># 抽取 <span class="number">2</span> 个二等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;Mark&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Jerry&quot;</span><br><span class="line"># 抽取 <span class="number">3</span> 个三等奖：</span><br><span class="line"><span class="operator">&gt;</span> SRANDMEMBER lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;Sary&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Tom&quot;</span><br><span class="line"><span class="number">3</span>) &quot;Jerry&quot;</span><br><span class="line"></span><br><span class="line">#如果不允许重复中奖，可以使用 SPOP 命令。</span><br><span class="line"># 抽取一等奖<span class="number">1</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) &quot;Sary&quot;</span><br><span class="line"># 抽取二等奖<span class="number">2</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) &quot;Jerry&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Mark&quot;</span><br><span class="line"># 抽取三等奖<span class="number">3</span>个</span><br><span class="line"><span class="operator">&gt;</span> SPOP lucky <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) &quot;John&quot;</span><br><span class="line"><span class="number">2</span>) &quot;Sean&quot;</span><br><span class="line"><span class="number">3</span>) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure>

<h2 id="5-Zset（压缩列表-跳表）"><a href="#5-Zset（压缩列表-跳表）" class="headerlink" title="5.Zset（压缩列表+跳表）"></a>5.Zset（压缩列表+跳表）</h2><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 往有序集合key中加入带分值元素</span><br><span class="line">ZADD key score <span class="keyword">member</span> [[score <span class="keyword">member</span>]...]   </span><br><span class="line"># 往有序集合key中删除元素</span><br><span class="line">ZREM key <span class="keyword">member</span> [member...]                 </span><br><span class="line"># 返回有序集合key中元素<span class="keyword">member</span>的分值</span><br><span class="line">ZSCORE key <span class="keyword">member</span></span><br><span class="line"># 返回有序集合key中元素个数</span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"># 为有序集合key中元素<span class="keyword">member</span>的分值加上increment</span><br><span class="line">ZINCRBY key increment <span class="keyword">member</span> </span><br><span class="line"></span><br><span class="line"># 正序获取有序集合key从<span class="keyword">start</span>下标到stop下标的元素</span><br><span class="line">ZRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line"># 倒序获取有序集合key从<span class="keyword">start</span>下标到stop下标的元素</span><br><span class="line">ZREVRANGE key <span class="keyword">start</span> stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"></span><br><span class="line"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT <span class="keyword">offset</span> count]</span><br><span class="line"></span><br><span class="line">#Zset 运算操作（相比于 <span class="keyword">Set</span> 类型，ZSet 类型没有支持差集运算）：</span><br><span class="line"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure>

<h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><h4 id="电话、姓名排序"><a href="#电话、姓名排序" class="headerlink" title="电话、姓名排序"></a>电话、姓名排序</h4><h2 id="6-BitMap"><a href="#6-BitMap" class="headerlink" title="6.BitMap"></a>6.BitMap</h2><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><h3 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h4><h4 id="判断用户登录态"><a href="#判断用户登录态" class="headerlink" title="判断用户登录态"></a>判断用户登录态</h4><h4 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h4><h1 id="Redis如何实现服务高可用？"><a href="#Redis如何实现服务高可用？" class="headerlink" title="Redis如何实现服务高可用？"></a>Redis如何实现服务高可用？</h1><p>1.主从复制</p>
<p>2.哨兵模式</p>
<p>3.切片集群</p>
<h1 id="缓存雪崩、击穿、穿透的解决方案？"><a href="#缓存雪崩、击穿、穿透的解决方案？" class="headerlink" title="缓存雪崩、击穿、穿透的解决方案？"></a>缓存雪崩、击穿、穿透的解决方案？</h1><h1 id="数据库和缓存如何保证一致性？"><a href="#数据库和缓存如何保证一致性？" class="headerlink" title="数据库和缓存如何保证一致性？"></a>数据库和缓存如何保证一致性？</h1><h2 id="更新数据库-更新缓存"><a href="#更新数据库-更新缓存" class="headerlink" title="更新数据库+更新缓存"></a>更新数据库+更新缓存</h2><p>应用场景：业务对缓存命中率有很高的要求（缓存的命中率越高则表示使用缓存的收益越高，应用的性能越好（响应时间越短、吞吐量越高），抗并发的能力越强。）</p>
<h3 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="1.先更新数据库，再更新缓存"></a>1.先更新数据库，再更新缓存</h3><p>存在问题：写写并发，更新同一条数据，导致数据不一致</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018105728145.png" alt="image-20221018105728145" style="zoom: 50%;" />

<p>解决方案：</p>
<p>方案1：在更新缓存前先加个<strong>分布式锁</strong>，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。</p>
<p>方案2：在更新完缓存时，给缓存加上较短的<strong>过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</p>
<h3 id="2-先更新缓存，再更新数据库"><a href="#2-先更新缓存，再更新数据库" class="headerlink" title="2.先更新缓存，再更新数据库"></a>2.先更新缓存，再更新数据库</h3><p>存在问题：写写并发，更新同一条数据，导致数据不一致</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018110413019.png" alt="image-20221018110413019" style="zoom:50%;" />

<p>解决方案：</p>
<p>方案：在更新完缓存时，给缓存加上较短的<strong>过期时间</strong>，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</p>
<h2 id="Cache-Aside-策略"><a href="#Cache-Aside-策略" class="headerlink" title="Cache Aside 策略"></a>Cache Aside 策略</h2><p><strong>思路：</strong>在更新数据时，不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</p>
<p><strong>写策略的步骤：</strong></p>
<ul>
<li>更新数据库中的数据；</li>
<li>删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018110841965.png" alt="image-20221018110841965" style="zoom:50%;" />

<p><strong>写策略顺序探讨</strong>：</p>
<h3 id="3-先删除缓存，后更新数据库"><a href="#3-先删除缓存，后更新数据库" class="headerlink" title="3.先删除缓存，后更新数据库"></a>3.先删除缓存，后更新数据库</h3><p>存在问题：写读并发</p>
<p>以用户表的场景来分析。假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018111223816.png" alt="image-20221018111223816" style="zoom:50%;" />

<p>解决方案：<strong>延迟双删</strong></p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018113054179.png" alt="image-20221018113054179" style="zoom: 80%;" />

<p>请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。</p>
<h3 id="4-先更新数据库，再删除缓存"><a href="#4-先更新数据库，再删除缓存" class="headerlink" title="4.先更新数据库，再删除缓存"></a>4.先更新数据库，再删除缓存</h3><p><strong>可能存在的问题：</strong>读写并发</p>
<p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018111531929.png" alt="image-20221018111531929" style="zoom:50%;" />

<p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。<strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p>
<p><strong>兜底策略：</strong>给缓存数据加上了「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致性。</p>
<p><strong>如果删除缓存失败怎么办？</strong></p>
<p>在删除缓存（第二个操作）的时候失败了，导致缓存中的数据是旧值，会导致数据库与缓存数据不一致。</p>
<p>解决方法：不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题。</p>
<p><strong>1.重试机制</strong></p>
<p>我们可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<ul>
<li>如果应用<strong>删除缓存失败（返回1成功）</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li>
<li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li>
</ul>
<p><strong>2.订阅MySQL binlog，再操作缓存。</strong></p>
<p>「<strong>先更新数据库，再删缓存</strong>」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除</p>
<h1 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h1><p>lock指令</p>
<h1 id="Sychronize锁升级过程"><a href="#Sychronize锁升级过程" class="headerlink" title="Sychronize锁升级过程"></a>Sychronize锁升级过程</h1><p>简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。<strong>不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销</strong>。</p>
<p>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁（此过程是不可逆的）</p>
<p><strong>markWord有64位,记录了锁信息和GC信息</strong></p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018164422691.png" alt="image-20221018164422691" style="zoom: 80%;" />

<p><strong>无锁态</strong>:  偏向锁位0    锁标志位 01</p>
<p><strong>偏向锁</strong>:  偏向锁位1     锁标志位 01</p>
<p><strong>自旋锁</strong>:  偏向锁位失效  锁标志位 00</p>
<p><strong>重量锁</strong>:  偏向锁位失效  锁标志位 10</p>
<p><strong>分代年龄</strong>: 当一个对象被垃圾回收器回收一次, GC+1, 回收次数超过一定数值 转移至老年代 .</p>
<p><strong>hashCode</strong>: 31位记录了hashCode, 如果对hashCode方法进行了调用, 则会把值记录在其中</p>
<p>最开始一个对象 被new出来 没有任何锁Object o &#x3D; new Object();此时是无锁态;来了个线程,当第一个线程要使用这个对象的时候,先不上锁 而是有个指针指向当前使用的线程, 升级为偏向锁,有一个指向当前线程的指针, 标记当前线程在使用这把锁, 称之为偏向锁,(我们可以理解为, markword中有一块地方记录了线程的线程id);当有线程来竞争锁的时候, 开始线程竞争,先撤销偏向锁状态,每个线程都有自己的线程栈, 在自己的线程栈中生成lock record(锁记录),谁先抢夺到资源, 则会把自己线程的lock Record的记录, 记录在轻量级锁中，使用自旋(CAS)的方式抢夺资源，此时有竞争的状态则升级为了轻量级锁，当进入轻量级锁以后 未能竞争上岗的线程则会一直自旋, 等待拿到轻量级锁，但是自旋的过程很消耗CPU (一般来讲有锁的情况下 线程是在队列里等待 不消耗CPU)，所以需要下一步的锁升级（默认自旋超过10次 或者 自旋等待线程超过CPU线程二分之一 ），当JVM发现线程竞争比较激烈, 且超过了JVM的自旋次数，JVM会向操作系统申请一把大锁（互斥锁Mutex）；在进入重量级锁后, 重量级锁会生成等待队列，所有线程进入等待队列，synchronize队列不是有序的(非公平锁)</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg4Mzc0MDA3OA==&amp;mid=2247483819&amp;idx=1&amp;sn=2b8745a4a8a6555dce4915385c3dedc2&amp;chksm=cf439d6af834147c05cf18a347787ef6f9c807fbd96c8c6605486c6b0baffec251276a4ec6b0&amp;mpshare=1&amp;scene=1&amp;srcid=10189YR19zpOWUIyLPvmhvEZ&amp;sharer_sharetime=1666070392548&amp;sharer_shareid=0207843a0a518495a90a17e4c5f836be#rd">https://mp.weixin.qq.com/s?__biz=Mzg4Mzc0MDA3OA==&amp;mid=2247483819&amp;idx=1&amp;sn=2b8745a4a8a6555dce4915385c3dedc2&amp;chksm=cf439d6af834147c05cf18a347787ef6f9c807fbd96c8c6605486c6b0baffec251276a4ec6b0&amp;mpshare=1&amp;scene=1&amp;srcid=10189YR19zpOWUIyLPvmhvEZ&amp;sharer_sharetime=1666070392548&amp;sharer_shareid=0207843a0a518495a90a17e4c5f836be#rd</a></p>
<h1 id="操作系统的锁"><a href="#操作系统的锁" class="headerlink" title="操作系统的锁"></a>操作系统的锁</h1><p>互斥锁、自旋锁、读写锁、悲观锁、乐观锁</p>
<p>最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的。</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<h1 id="在项目中有什么难点？"><a href="#在项目中有什么难点？" class="headerlink" title="在项目中有什么难点？"></a>在项目中有什么难点？</h1><p>在我负责的这部分用到了多线程（数据量比较大、处理快一点、异步方式）、MQ、以及分布式锁的一些知识</p>
<p>线程池的线程数配多少？</p>
<h2 id="线程池里的线程数量设置多少合适"><a href="#线程池里的线程数量设置多少合适" class="headerlink" title="线程池里的线程数量设置多少合适"></a>线程池里的线程数量设置多少合适</h2><ul>
<li>CPU密集型（加密、计算hash等）：最佳线程数为CPU核心数的1-2倍左右。</li>
<li>耗时IO型（读写数据库、文件、网络读写等）：最佳线程数一般会大于CPU核心数很多倍<ul>
<li>线程数&#x3D;CPU核心数*（1+平均等待时间&#x2F;平均工作时间）</li>
<li>更精确可以压测。（模拟数据，在测试环境跑一下，看单位时间内能跑多少数据，看一下性能）</li>
</ul>
</li>
</ul>
<p>线程为什么不是配置越多越好？</p>
<p>因为线程过多增加cpu上下文切换成本，反而影响性能</p>
<p>协程能支持更多的并发，有了解协程和线程的区别吗？</p>
<p>在一个线程内实现并行并发的效果</p>
<p>线程的切换（cpu的切换)?</p>
<p>切换的时候cpu的缓存失效，只能重新从内存中去读取线程相关内容（上一次执行的位置等信息），因为缓存不断的失效，不断的从内存中读取，会造成一些性能的下降</p>
<p>每次CPU内部的缓存线程共享的吗？还是线程私有的？</p>
<p>线程私有的，用volatile（不用加锁，汇编的层面有个lock的指令，）、sychronized（粒度较大，当锁升级为重量级锁的时候，会造成线程阻塞）或lock锁实现线程间的同步</p>
<p>哪种场景适合用volatile？哪种场景适合用sychronized？哪种场景适合用lock？</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>corePoolSize</code> 线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize, 即使有其他空闲线程能够执行新来的任务, 也会继续创建线程；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li><code>workQueue</code> 用来保存等待被执行的任务的阻塞队列. 在JDK中提供了如下阻塞队列:  <ul>
<li><code>ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；</li>
<li><code>LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；</li>
<li><code>SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；</li>
<li><code>PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</li>
</ul>
</li>
</ul>
<p><code>LinkedBlockingQueue</code>比<code>ArrayBlockingQueue</code>在插入删除节点性能方面更优，但是二者在<code>put()</code>, <code>take()</code>任务的时均需要加锁，<code>SynchronousQueue</code>使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是<code>Transfer.transfer()</code>.</p>
<ul>
<li><p><code>maximumPoolSize</code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</p>
</li>
<li><p><code>keepAliveTime</code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用, 超过这个时间的空闲线程将被终止；</p>
</li>
<li><p><code>unit</code> keepAliveTime的单位</p>
</li>
<li><p><code>threadFactory</code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory</p>
</li>
<li><p><code>handler</code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>
<ul>
<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>
<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>
<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>
<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>
</ul>
</li>
</ul>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h2 id="如果一个线程池要关闭它？你会用什么方法？"><a href="#如果一个线程池要关闭它？你会用什么方法？" class="headerlink" title="如果一个线程池要关闭它？你会用什么方法？"></a>如果一个线程池要关闭它？你会用什么方法？</h2><p>遍历线程池中的所有线程，然后逐个调用线程的interrupt方法来中断线程.</p>
<p>**shutdown():**将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程.停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。当所有提交任务执行完毕，线程池即被关闭。</p>
<p>**awaitTermination():**阻塞等待所有任务都执行完毕再关闭线程池,接收人timeout和TimeUnit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestShutDown</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">LongTask</span>());</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!service.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程池没有关闭&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已经关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">普通任务</span><br><span class="line">普通任务</span><br><span class="line">长时间任务</span><br><span class="line">普通任务</span><br><span class="line">线程池没有关闭</span><br><span class="line">线程池没有关闭</span><br><span class="line">线程池没有关闭</span><br><span class="line">线程池没有关闭</span><br><span class="line">线程池已经关闭</span><br></pre></td></tr></table></figure>

<p><strong>shutdownNow()：</strong>将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程.</p>
<h2 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h2><p>1、execut()可以添加一个Runable任务,submit()不仅可以添加Runable任务还可以添加Callable任务。</p>
<p>2、execut()没有返回值,而submit()在添加Callable任务时会有返回值(再添加Runable任务时也有,不过无意义),可以通过返回值来查看线程执行的情况。</p>
<p>3、如果发生异常submit()可以通过捕获Future.get抛出的异常,而execute()会终止这个线程。</p>
<p>通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。通过Executor.execute方法提交FutureTask到线程池中等待被执行，最终执行的是FutureTask的run方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// submit方法在AbstractExecutorService中的实现</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 通过submit方法提交的Callable任务会被封装成了一个FutureTask对象。</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;l</span><br></pre></td></tr></table></figure>

<h2 id="配置线程池需要考虑因素"><a href="#配置线程池需要考虑因素" class="headerlink" title="配置线程池需要考虑因素"></a>配置线程池需要考虑因素</h2><p>从任务的优先级，任务的执行时间长短，任务的性质(CPU密集&#x2F; IO密集)，任务的依赖关系这四个角度来分析。并且近可能地使用有界的工作队列。</p>
<p>性质不同的任务可用使用不同规模的线程池分开处理:</p>
<ul>
<li>CPU密集型: 尽可能少的线程，Ncpu+1</li>
<li>IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池</li>
<li>混合型: CPU密集型的任务与IO密集型任务的执行时间差别较小，拆分为两个线程池；否则没有必要拆分。</li>
</ul>
<h2 id="监控线程池的状态"><a href="#监控线程池的状态" class="headerlink" title="监控线程池的状态"></a>监控线程池的状态</h2><p>可以使用ThreadPoolExecutor以下方法:</p>
<ul>
<li><code>getTaskCount()</code> Returns the approximate total number of tasks that have ever been scheduled for execution.返回线程池收到的任务总数。</li>
<li><code>getCompletedTaskCount()</code> Returns the approximate total number of tasks that have completed execution. 返回线程池完成任务的数量。返回结果少于getTaskCount()。</li>
<li><code>getLargestPoolSize()</code> Returns the largest number of threads that have ever simultaneously been in the pool.返回线程池曾经达到的线程的最大数。 返回结果小于等于maximumPoolSize</li>
<li><code>getPoolSize()</code> Returns the current number of threads in the pool.当前线程池的大小。</li>
<li><code>getActiveCount()</code> Returns the approximate number of threads that are actively executing tasks. 获得线程池中当前活动线程的数量。</li>
<li>BlockingQueue getQueue() 返回阻塞队列。</li>
</ul>
<p>longAddress和AtomicLong区别？（高并发场景下效率高）</p>
<p>RetrreenLock（JUC包里）和sychronized（JVM层面关键字）区别？</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h1 id="重入锁概念？"><a href="#重入锁概念？" class="headerlink" title="重入锁概念？"></a>重入锁概念？</h1><p>假如说有一个线程已经持有这个锁了，有可能以递归的形式或者调用另外一个方法的方式再次去尝试持有这个锁，可重入锁就不用再去竞争了，就可以直接进入到这个锁里</p>
<h2 id="redis实现重入锁？"><a href="#redis实现重入锁？" class="headerlink" title="redis实现重入锁？"></a>redis实现重入锁？</h2><p>（可以，value） (锁计数,占有线程)</p>
<p>redis存一个整数，先判断锁计数是不是0，是0，就可以持有，不是0，判断是不是当前线程，是当前线程就Increment加1，释放锁就减1，减为0就将（key，value）删除掉或置为空，原子性的过程可以用Lua脚本来保证，锁应该设置一个超时时间，防止客户端挂掉</p>
<p><strong>代码中事务传播怎么做的？</strong></p>
<p>事务传播行为用来描述<strong>由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播</strong>。</p>
<p>用伪代码说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">   methodB();</span><br><span class="line">   <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction(Propagation=XXX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7种</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221018205736378.png" alt="image-20221018205736378"  />

<p>REQUIRED:<strong>在外围方法未开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。在外围方法开启事务的情况下<code>Propagation.REQUIRED</code>修饰的内部方法会加入到外围方法的事务中，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外围方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</strong></p>
<p>REQUIRES_NEW：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/IglQITCkmx7Lpz60QOW7HA">https://mp.weixin.qq.com/s/IglQITCkmx7Lpz60QOW7HA</a></p>
<p><strong>什么是编程式事务？什么是声明式事务？</strong></p>
<p>所谓声明式事务，就是通过配置的方式，比如通过配置文件（xml）或者注解的方式，告诉spring，哪些方法需要spring帮忙管理事务，然后开发者只用关注业务代码，而事务的事情spring自动帮我们控制。</p>
<p>编程式事务基于底层的API，如PlatformTransactionManager、TransactionDefinition 和 TransactionTemplate 等核心接口，开发者完全可以通过编程的方式来进行事务管理。<strong>编程式事务方式需要是开发者在代码中手动的管理事务的开启、提交、回滚等操作。</strong></p>
<h1 id="Spring容器加载，启动过程？"><a href="#Spring容器加载，启动过程？" class="headerlink" title="Spring容器加载，启动过程？"></a>Spring容器加载，启动过程？</h1><p>beanFactory</p>
<p>动态代理？</p>
<p>模板方法？</p>
<h1 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h1><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/KWb3POodisbOEsQVblsoGw">https://mp.weixin.qq.com/s/KWb3POodisbOEsQVblsoGw</a></p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221019114532915.png" alt="image-20221019114532915" style="zoom: 80%;" />

<p>秒杀出现的几个问题：</p>
<p><strong>高并发：</strong>秒杀大家都知道如果真的营销到位，价格诱人，几十万的流量我觉得完全不是问题，单机的<strong>Redis</strong>我感觉3-4W的QPS还是能顶得住的，但是再高了就没办法了，那这个数据随便搞个热销商品的秒杀可能都不止了。大量的请求进来，我们需要考虑的点就很多了，<strong>缓存雪崩</strong>，<strong>缓存击穿</strong>，<strong>缓存穿透</strong>这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是<strong>开发</strong>。  CDN资源静态化（秒杀一般都是特定的商品还有页面模板，就把能提前放入<strong>cdn服务器</strong>的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。）  限流组件、风控   秒杀数量过高用MQ改库  </p>
<p><strong>超卖：</strong>但凡是个秒杀，都怕<strong>超卖</strong>，我这里举例的只是尿不湿，要是换成100个MacBook Pro，商家的预算经费卖100个可以赚点还可以造势，结果你写错程序多卖出去200个，你不发货用户<strong>投诉你</strong>，平台<strong>封你店</strong>，你发货就<strong>血亏</strong>，你怎么办？Redis Lua脚本</p>
<p><strong>恶意请求：</strong>你这么低的价格，假如我抢到了，我转手卖掉我不是<strong>血赚</strong>？那简单啊，我知道你什么时候抢，我搞个几十台机器搞点脚本，我也模拟出来十几万个人左右的请求，那我是不是意味着我基本上有80%的成功率了。 风控控制</p>
<p><strong>链接暴露：</strong>开发知道地址，在秒杀的时候自己提前请求。。。秒杀链接加盐：把<strong>URL动态化</strong>，就连写代码的人都不知道，你就通过MD5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p>
<p><strong>数据库：</strong>每秒上万甚至十几万的<strong>QPS</strong>（每秒请求数）直接打到<strong>数据库</strong>，基本上都要把库打挂掉，而且你服务不单单是做秒杀的还涉及其他的业务，你没做<strong>降级、限流、熔断</strong>啥的，别的一起挂，小公司的话可能<strong>全站崩溃404</strong>。</p>
<p>数据库用MySQL只要连接池设置合理一般问题是不大的，不过一般大公司不缺钱而且秒杀这样的活动十分频繁，我之前所在的公司就是这样秒杀特卖这样的场景一直都是不间断的。单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是<strong>分库</strong>的。至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用<strong>explain</strong>看看<strong>SQL</strong>的执行计划。</p>
<h1 id="分区分库分表"><a href="#分区分库分表" class="headerlink" title="分区分库分表"></a>分区分库分表</h1><p>对于一个日活用户在百万数量级的商城来说，每天产生的订单数量可能在百万级，特别在一些活动促销期间，甚至上千万。假设我们基于单表来实现，每天产生上百万的数据量，不到一个月的时间就要承受上亿的数据，这时单表的性能将会严重下降。因为 MySQL 在 InnoDB 存储引擎下创建的索引都是 基于 B+ 树实现的，所以查询时的 I&#x2F;O 次数很大程度取决于树的高度，随着 B+ 树的树高增高，I&#x2F;O 次数增加，查询性能也就越差。</p>
<p>当我们面对一张海量数据的表时，通常有<strong>分区、NoSQL 存储、分表分库</strong>等优化方案。</p>
<p><strong>分区：</strong>分区的底层虽然也是基于分表的原理实现的，即有多个底层表实现，但分区依然是在单库下进行的，在一些需要提高并发的场景中的优化空间非常有限，且一个表最多只能支持 1024个分区。面对日益增长的海量数据，优化存储能力有限。不过 在一些非海量数据的大表中，我们可以考虑使用分区来优化表性能。</p>
<p><strong>NoSQL 存储：</strong>基于键值对存储，虽然查询性能非常高，但在一些方面仍然存在短板。例如，不是关系型数据库，不支持事务以及稳定性方面相对 RDBMS 差一些。虽然有些NoSQL 数据库也实现了事务，宣传具有可靠的稳定性，但 目前 NoSQL 还是主要用作辅助存储 。</p>
<p><strong>分库分表：</strong>在我看来，能不分表分库就不要分表分库。 在单表的情况下，当业务正常时，我们使用单表即可，而当业务出现了性能瓶颈时，我们首先考虑用分区的方式来优化，如果分区优化之后仍然存在后遗症，此时我们再来考虑分表分库。</p>
<p>我们知道，如果在单表单库的情况下，当数据库表的数据量逐渐累积到一定的数量时（5000W 行或 100G 以上），操作数据库的性能会出现明显下降，即使我们使用索引优化或读写库分离，性能依然存在瓶颈。此时，如果每日数据增长量非常大，我们就应该考虑分表，避免单表数据量过大，造成数据库操作性能下降。 面对海量数据，除了单表的性能比较差以外，我们在单表单库的情况下，数据库连接数、磁盘 I&#x2F;O 以及网络吞吐等资源都是有限的，并发能力也是有限的。所以，在一些大数据量且高并发的业务场景中，我们就需要考虑分表分库来提升数据库的并发处理能力，从而提升应用的整体性能。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenyong6301567/article/details/126587108?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166615701316782388021117%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166615701316782388021117&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126587108-null-null.142">https://blog.csdn.net/chenyong6301567/article/details/126587108?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166615701316782388021117%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166615701316782388021117&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126587108-null-null.142</a></p>
<p>为了更容易理解这些问题，我们将对一个订单表进行分库分表，通过详细的业务来分析这些问题。</p>
<p>假设我们有一张订单表以及一张订单详情表，每天的数据增长量在 60W 单，平时还会有一些促销类活动，订单增长量在千万单。为了提高系统的并发能力，我们考虑将订单表和订单详情表做分库分表。除了分表，因为用户一般查询的是最近的订单信息，所以热点数据比较</p>
<p>集中，我们还可以考虑用表分区来优化单表查询。</p>
<p>通常订单的分库分表要么基于订单号 Hash 取模实现，要么根据用户 ID Hash 取模实现。订单号 Hash 取模的好处是数据能均匀分布到各个表中，而缺陷则是一个用户查询所有订单时，需要去多个表中查询。</p>
<p>由于订单表用户查询比较多，此时我们应该考虑使用用户 ID 字段做 Hash 取模，对订单表进行水平分表。如果需要考虑高并发时的订单处理能力，我们可以考虑基于用户 ID 字段Hash 取模实现分库分表。这也是大部分公司对订单表分库分表的处理方式。</p>
<p><strong>分库分表存在问题：</strong></p>
<p>1.分布式事务问题</p>
<p>在提交订单时，除了创建订单之外，我们还需要扣除相应的库存。而订单表和库存表由于垂直分库，位于不同的库中，这时我们需要通过分布式事务来保证提交订单时的事务完整性。通常，我们解决分布式事务有两种通用的方式：两阶事务提交（2PC）以及补偿事务提交（TCC）。有关分布式事务的内容，我将在第 41 讲中详细介绍。通常有一些中间件已经帮我们封装好了这两种方式的实现，例如 Spring 实现的 JTA，目前阿里开源的分布式事务中间件 Fescar，就很好地实现了与 Dubbo 的兼容。</p>
<p>2.跨节点JOIN查询问题</p>
<p>3.跨节点分页查询问题</p>
<p>4.全局主键ID问题</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>两阶事务提交（2PC）以及补偿事务提交（TCC）</p>
<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><ul>
<li>配置管理</li>
<li>集群管理</li>
<li>分布式锁</li>
</ul>
<p>分布式锁、集群选举机制</p>
<h1 id="RPC框架的架构原理"><a href="#RPC框架的架构原理" class="headerlink" title="RPC框架的架构原理"></a>RPC框架的架构原理</h1><p>三部分组成：服务提供者、注册中心、服务消费者</p>
<h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p>当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如<strong>一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的</strong>，不是说任意访问一个节点都可以得到缓存结果的。</p>
<p>有的同学可能很快就想到了：<strong>哈希算法</strong>。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。</p>
<p>哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 <code>hash(key) % 3</code> 公式对数据进行了映射。</p>
<p>但是有一个很致命的问题，<strong>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</strong>，否则会出现查询不到数据的问题。</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<strong>一致哈希算法是对 2^32 进行取模运算，是一个固定的值</strong>。</p>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为<strong>哈希环</strong></p>
<p>一致性哈希要进行两步哈希：</p>
<ul>
<li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li>
<li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；</li>
</ul>
<p>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p>
<p>问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？</p>
<p>答案是，映射的结果值往<strong>顺时针的方向的找到第一个节点</strong>，就是存储该数据的节点。</p>
<p>因此，<strong>在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</strong>。</p>
<p>但是<strong>一致性哈希算法并不保证节点能够在哈希环上分布均匀</strong>，这样就会带来一个问题，会有大量的请求集中在一个节点上。</p>
<p>另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。</p>
<p>比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。</p>
<p>所以，<strong>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</strong>。</p>
<p> <strong>如何通过虚拟节点提高均衡度？</strong></p>
<p>所以这个时候我们就加入<strong>虚拟节点</strong>，也就是对一个真实节点做多个副本。</p>
<p>具体做法是，<strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</strong></p>
<p>另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<strong>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</strong>。</p>
<p>比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。</p>
<p>而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</p>
<p>因此，<strong>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p>
<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>其中类加载的过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。在这五个阶段中，<code>加载</code>、<code>验证</code>、<code>准备</code>和<code>初始化</code>这四个阶段发生的顺序是确定的，*而<code>解析</code>阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)*。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221020103920345.png" alt="image-20221020103920345" style="zoom: 80%;" />

<h2 id="类的加载-查找并加载类的二进制数据"><a href="#类的加载-查找并加载类的二进制数据" class="headerlink" title="类的加载: 查找并加载类的二进制数据"></a>类的加载: 查找并加载类的二进制数据</h2><p>加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221020104339785.png" alt="image-20221020104339785" style="zoom:50%;" />

<p>相对于类加载的其他阶段而言，<em>加载阶段(准确地说，是加载阶段获取类的二进制字节流的动作)是可控性最强的阶段</em>，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221020110147623.png" alt="image-20221020110147623" style="zoom:67%;" />

<p><strong>双亲委派机制过程？</strong></p>
<ol>
<li>当AppClassLoader（应用程序类加载器）加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader（扩展类加载器）加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader（启动类加载器）加载失败(例如在$JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<p><strong>自定义类加载器</strong></p>
<p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可。</p>
<h2 id="验证-确保被加载的类的正确性"><a href="#验证-确保被加载的类的正确性" class="headerlink" title="验证: 确保被加载的类的正确性"></a>验证: 确保被加载的类的正确性</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作:</p>
<ul>
<li><code>文件格式验证</code>: 验证字节流是否符合Class文件格式的规范；例如: 是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><code>元数据验证</code>: 对字节码描述的信息进行语义分析(注意: 对比<code>javac</code>编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了<code>java.lang.Object</code>之外。</li>
<li><code>字节码验证</code>: 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><code>符号引用验证</code>: 确保解析动作能正确执行。</li>
</ul>
<h2 id="准备-为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备-为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备: 为类的静态变量分配内存，并将其初始化为默认值"></a>准备: 为类的静态变量分配内存，并将其初始化为默认值</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。</p>
<h2 id="解析-把类中的符号引用转换为直接引用"><a href="#解析-把类中的符号引用转换为直接引用" class="headerlink" title="解析: 把类中的符号引用转换为直接引用"></a>解析: 把类中的符号引用转换为直接引用</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用就是一组符号来描述目标，可以是任何字面量。<code>直接引用</code>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化，<strong>为类的静态变量赋予正确的初始值</strong>，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式:</p>
<ul>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p><strong>类初始化时机</strong>: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射(如Class.forName(“com.pdai.jvm.Test”))</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(Java Test)，直接使用java.exe命令来运行某个主类</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>类访问方法区内的数据结构的接口， 对象是Heap区的数据。</p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><strong>Java虚拟机将结束生命周期的几种情况</strong></p>
<ul>
<li>执行了System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h1 id="为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？"><a href="#为什么-MySQL-InnoDB-选择-B-tree-作为索引的数据结构？" class="headerlink" title="为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？"></a>为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</h1><p>另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p>
<p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p>
<p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因</p>
<h4 id="什么时候适用索引？"><a href="#什么时候适用索引？" class="headerlink" title="什么时候适用索引？"></a>什么时候适用索引？</h4><ul>
<li>字段有唯一性限制的，比如商品编码；</li>
<li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li>
<li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li>
</ul>
<h4 id="什么时候不需要创建索引什么时候不需要创建索引？"><a href="#什么时候不需要创建索引什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引什么时候不需要创建索引？"></a>什么时候不需要创建索引什么时候不需要创建索引？</h4><ul>
<li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li>
<li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li>
<li>表数据太少的时候，不需要创建索引；</li>
<li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li>
</ul>
<h2 id="有什么优化索引的方法？"><a href="#有什么优化索引的方法？" class="headerlink" title="有什么优化索引的方法？"></a>有什么优化索引的方法？</h2><p>这里说一下几种常见优化索引的方法：</p>
<ul>
<li>前缀索引优化：使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效；</li>
</ul>
<p>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</p>
<p>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</p>
<p>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</p>
<p>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p>
<h1 id="既然有HTTP协议，为什么还要有RPC？"><a href="#既然有HTTP协议，为什么还要有RPC？" class="headerlink" title="既然有HTTP协议，为什么还要有RPC？"></a>既然有HTTP协议，为什么还要有RPC？</h1><p>TCP：面向连接、可靠、基于字节流</p>
<p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 <strong>01 串</strong>。纯裸TCP收发的这些 01 串之间是<strong>没有任何边界</strong>的，你根本不知道到哪个地方才算一条完整消息。</p>
<p>正因为这个没有<strong>任何边界</strong>的特点，所以当我们选择使用TCP发送**”夏洛”和”特烦恼”<strong>的时候，接收端收到的就是</strong>“夏洛特烦恼”<strong>，这时候接收端没发区分你是想要表达</strong>“夏洛”+”特烦恼”<strong>还是</strong>“夏洛特”+”烦恼”<strong>。这就是所谓的</strong>粘包问题**。</p>
<p>于是我们会把每条要发送的数据都包装一下，比如加入<strong>消息头</strong>，<strong>消息头里写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的<strong>消息体</strong>。</p>
<p>而这里头提到的<strong>消息头</strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong></p>
<p><strong>于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC。</strong></p>
<p>值得注意的是，虽然大部分RPC协议底层使用TCP，但实际上<strong>它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。</strong></p>
<p>而<strong>RPC</strong>协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。</p>
<p><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池</strong>，比如<strong>go</strong>就是这么干的。</p>
<p><strong>body</strong>则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如<strong>json，protobuf。</strong></p>
<p>这个将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。</p>
<p>而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</strong> </p>
<h1 id="大厂里面如何做高性能数据库的一些优化的？"><a href="#大厂里面如何做高性能数据库的一些优化的？" class="headerlink" title="大厂里面如何做高性能数据库的一些优化的？"></a>大厂里面如何做高性能数据库的一些优化的？</h1><p>1.常见的sql优化、索引覆盖</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023191352481.png" alt="image-20221023191352481" style="zoom:50%;" />

<p>2.反范式设计：逻辑上同一个字段我们缓存（冗余）在多个表里，为什么要做这种表的冗余，因为很多时候我们去做查询，要去做关联查询，这个对性能的影响还是比较大的，如果单纯的是查询可能还好，但是如果是更新，比如说有A、B两张表，这两张表有一个外键，它们把它关系起来的，这个时候你可能先去查B表，然后再通过查出来的这个值去更新A表，这样你会发现整个事务会拉大，比如说你B表查出来的数据量比较大，那你本地的内存压力也会比较大，如果你把这个WHERE条件的字段直接冗余到A表里面，你就可以单表去进行更新了，这样就能避免我之前说的两个问题，而且能提升整个表更新的一个并发量，但是这里也会有另外一个副作用，你这个where条件本身的字段去更新的话，你就要去更新两张表，如果更新的这个字段是非常高频的操作，那其实本身也会拉大这个事务，所以你就要结合你的场景去分析，它到底是属于哪一种情况，去做这种反范式设计。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023191705500.png" alt="image-20221023191705500" style="zoom: 50%;" />

<p>3.不要去设置外键：你要去做一个更新，如果涉及到外键的话，你要额外的去做一些操作，而且这个操作之间可能会去加锁，那这样对更新操作其实是有些性能影响的，所以外键这个东西，我们一般是不会直接设置在数据库上，更多是在业务层面去做一个约束。这也可以延伸一下很多公司的数据库的隔离级别并不是采用默认的可重复读，而是采用的是读已提交，不同的隔离级别很大程度都是通过一些锁机制去实现的，所以省掉这些锁的开销能一定程度提升你的一个并发度，这就是性能跟完整性一些权衡取舍，这个也要根据你的实际业务场景来</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023192100096.png" alt="image-20221023192100096" style="zoom:50%;" />

<p>4、字段扩展性问题：一个很简单的例子，比如说你在业务上要填一个表格，但是这个表格的样式或者字段，它是动态变化的，那这个数据库表字段的设计应该怎么去做，这里就有两种方案了，第一种方案，就是把所有的表单类型给它枚举出来，把每一个要填的项目都给它建成一个独立的字段，这样你就会发现一个问题，这个表会变得非常大，而且后面新增加了表的样式之后，你的字段也会不断的去调整，数据库建表字段应该是一个比较稳定的概念，如果你频繁根据业务去进行一些调整，去进行动态的调整，那这个运维的成本其实是非常高的，这里很多人会想到用NOSQL像mongoDB这种文档数据库去做这种事情，因为它不需要事先去定义它的结构，其实就在关系型数据库层面，我们也可以去建一个通用的字段，这个字段就存一个字符串，这个字符串就是一个JSON，你这个表单的全部内容就存在一个JSON给它传进去，去保存整个表单它里面填的所有的key value，你要去展示表格的时候后端不需要关心这个表里面具体有哪些key value，直接把这个字符串丢给前端，它自己去解析就行了，后端对于这个表单内容的解析就会非常简单，其实这个方案也是有一定缺陷的，比如说你要通过这个表里面的一些key-value去做一些索引（查询），但是你在表里面存的就是一个字符串，你怎么去做索引呢，你当然可以用like一些语句去实现，但是这样性能就非常低了，你没办法用到mysql底层的一些B+树的索引，所以mysql的高版本也支持JSON的这种数据结构好像也支持索引，但是我们实际在生产环境中，还是会去考虑这个点，如果真的里面的这个字段需要索引的话，我们会把它拆出来</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023192914673.png" alt="image-20221023192914673" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023195742781.png" alt="image-20221023195742781" style="zoom:50%;" />

<p>5.冷热分离：我们可以在表层面去做一个冷热分离，比如说商品表它有些字段是高频的要增删改查的，但是有一些字段它基本上不怎么变化，而且这些不变化的字段存的数据量还比较大，如果把所有的字段放在一个商品表里面，那这样的话，后面的数据增删改查其实性能都会非常低，所以关于商品的存储模型，我们会建两张表，一张是商品的主表，另外一张是商品的扩展表，把频繁增删改查的字段放在主表里面去，然后把用的比较少的一些字段放在扩展表里面去，那这样主表它的一个增删改查，包括它索引的构建，这样性能都能提升很多</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023201308805.png" alt="image-20221023201308805" style="zoom:50%;" />

<p>6.事务：数据库的集群，我们去做拆分的时候，会习惯性的去考虑同一块业务把它放在一起，这确实也是符合微服务的一些思想的，但是我i们还是要去考虑一些技术上的挑战，比如后期业务上同一些操作可能涉及到事务问题，尽量把它放在一个数据库里面。还是拿电商的场景，你数据库分片的时候，你不知道通过哪一个维度去分片，但是你知道有些操作是在用户维度的，有些操作是在店铺的维度，那同一个店铺的一些操作，那我们就去给它做一个分片。分布式事务最好的解决方案就是你在做服务拆分的时候，数据库层面你都要考虑好，怎么去尽量避免分布式事务。</p>
<img src="https://raw.githubusercontent.com/zhangtao-cpu/blog_imgs/main/hexoImage/image-20221023201707966.png" alt="image-20221023201707966" style="zoom:50%;" />

<p>7.尽量单表操作：还是要看具体场景，像一些传统的系统，它大量的业务都是用存储过程去实现的，一个SQL几千行，人家系统也运行的好好的，也没有什么大的问题啊，所以说存在即合理，这个真的是要看具体场景，那什么场景比较适合用这种单表操作呢，互联网公司一般都是采用这种增量式迭代的开发，一个很大的原因是你未来的需求是不确定的，所以抛开这种连表查询的性能问题，可能更多的就是为了后期的分库分表更加的方便，再加上应用服务器这一块，它弹性也是很大的，如果内存上有压力的话，我们可以去横向的扩容，也算是一种以空间换时间的思想，但是这个性能没有绝对的优劣，因为你单表去JOIN，虽然在数据库层面开销要大一点，但是应用节点跟数据库之间的IO其实只有一次，所以说具体哪一种性能好一点，这个还不好说，主要还是你整个SQL写的很复杂之后，你后期去做分库分表，做拆分的时候会非常的麻烦，同样你要去做这一块的前瞻性设计，你要考虑你这个是用自增ID还是用这种分布式的ID，如果你这个表的ID要去做外键，而且后期大概率这个表要去做分库分表，那你尽量前期就去做分布式ID的生成</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/31/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">http://example.com/2022/10/31/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/31/meituan-interview/" title="meituan interview"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">meituan interview</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/16/Just-for-test/" title="Just for test"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Just for test</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">Redis常见数据类型和应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-String%EF%BC%88SDS%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.String（SDS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">场景使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E8%AE%A1%E7%AE%97%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0%E3%80%81%E8%BD%AC%E5%8F%91%E3%80%81%E5%BA%93%E5%AD%98%E6%95%B0%E9%87%8F%E3%80%81%E6%96%87%E7%AB%A0%E7%9A%84%E9%98%85%E8%AF%BB%E9%87%8F%E7%AD%89%E7%AD%89%EF%BC%89"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.计数器（计算访问次数、转发、库存数量、文章的阅读量等等）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1%EF%BC%88%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%AD%89%EF%BC%89"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.缓存对象（用户信息等）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3.分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B1%E4%BA%ABSession%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">4.共享Session信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-List%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">2.List（压缩列表+双向链表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">消息队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Hash%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3.Hash（压缩列表+哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1-%E5%A6%82%E8%B4%AD%E7%89%A9%E8%BD%A6"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">缓存对象(如购物车)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Set%EF%BC%88%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">4.Set（整数集合+哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">共同关注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E5%A5%96%E6%B4%BB%E5%8A%A8"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">抽奖活动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Zset%EF%BC%88%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-%E8%B7%B3%E8%A1%A8%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">5.Zset（压缩列表+跳表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">1.5.2.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">排行榜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E3%80%81%E5%A7%93%E5%90%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">电话、姓名排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-BitMap"><span class="toc-number">1.6.</span> <span class="toc-text">6.BitMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">1.6.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">1.6.2.</span> <span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">签到统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%80%81"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">判断用户登录态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%BB%E6%95%B0"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">连续签到用户总数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">Redis如何实现服务高可用？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">缓存雪崩、击穿、穿透的解决方案？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">数据库和缓存如何保证一致性？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.</span> <span class="toc-text">更新数据库+更新缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.先更新数据库，再更新缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%8C%E5%86%8D%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.先更新缓存，再更新数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-Aside-%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.</span> <span class="toc-text">Cache Aside 策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.先删除缓存，后更新数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%86%8D%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.先更新数据库，再删除缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Volatile"><span class="toc-number">5.</span> <span class="toc-text">Volatile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sychronize%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">Sychronize锁升级过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">操作系统的锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E9%9A%BE%E7%82%B9%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">在项目中有什么难点？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%B0%91%E5%90%88%E9%80%82"><span class="toc-number">8.1.</span> <span class="toc-text">线程池里的线程数量设置多少合适</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A6%81%E5%85%B3%E9%97%AD%E5%AE%83%EF%BC%9F%E4%BD%A0%E4%BC%9A%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">如果一个线程池要关闭它？你会用什么方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="toc-number">9.2.</span> <span class="toc-text">任务的提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">9.3.</span> <span class="toc-text">配置线程池需要考虑因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">9.4.</span> <span class="toc-text">监控线程池的状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">10.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E9%94%81%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">重入锁概念？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">redis实现重入锁？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E5%AE%B9%E5%99%A8%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">Spring容器加载，启动过程？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">13.</span> <span class="toc-text">秒杀系统设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">14.</span> <span class="toc-text">分区分库分表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">15.</span> <span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zookeeper"><span class="toc-number">16.</span> <span class="toc-text">zookeeper</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-number">17.</span> <span class="toc-text">RPC框架的架构原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">18.</span> <span class="toc-text">一致性哈希</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">19.</span> <span class="toc-text">类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E6%9F%A5%E6%89%BE%E5%B9%B6%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">19.1.</span> <span class="toc-text">类的加载: 查找并加载类的二进制数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">19.1.1.</span> <span class="toc-text">JVM类加载机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-%E7%A1%AE%E4%BF%9D%E8%A2%AB%E5%8A%A0%E8%BD%BD%E7%9A%84%E7%B1%BB%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">19.2.</span> <span class="toc-text">验证: 确保被加载的类的正确性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87-%E4%B8%BA%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">19.3.</span> <span class="toc-text">准备: 为类的静态变量分配内存，并将其初始化为默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-%E6%8A%8A%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8"><span class="toc-number">19.4.</span> <span class="toc-text">解析: 把类中的符号引用转换为直接引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">19.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">19.6.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD"><span class="toc-number">19.7.</span> <span class="toc-text">卸载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-MySQL-InnoDB-%E9%80%89%E6%8B%A9-B-tree-%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%82%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">20.0.0.1.</span> <span class="toc-text">什么时候适用索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">20.0.0.2.</span> <span class="toc-text">什么时候不需要创建索引什么时候不需要创建索引？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">20.1.</span> <span class="toc-text">有什么优化索引的方法？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">既然有HTTP协议，为什么还要有RPC？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%87%8C%E9%9D%A2%E5%A6%82%E4%BD%95%E5%81%9A%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">大厂里面如何做高性能数据库的一些优化的？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/02/Hexo%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%91%BD%E4%BB%A4/" title="Hexo目录结构及命令">Hexo目录结构及命令</a><time datetime="2023-05-02T15:44:07.000Z" title="Created 2023-05-02 23:44:07">2023-05-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/31/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95/" title="美团面试">美团面试</a><time datetime="2022-10-31T04:09:13.000Z" title="Created 2022-10-31 12:09:13">2022-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/31/java%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/" title="java基础技术">java基础技术</a><time datetime="2022-10-31T04:04:27.000Z" title="Created 2022-10-31 12:04:27">2022-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/31/meituan-interview/" title="meituan interview">meituan interview</a><time datetime="2022-10-31T04:04:27.000Z" title="Created 2022-10-31 12:04:27">2022-10-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/31/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" title="No title">No title</a><time datetime="2022-10-31T03:41:15.101Z" title="Created 2022-10-31 11:41:15">2022-10-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":200,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>